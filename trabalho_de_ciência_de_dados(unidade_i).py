# -*- coding: utf-8 -*-
"""Trabalho de ciência de dados(Unidade I).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lnSDCqtgMXTZqK52IQD-LYMFBSk0hoJA

# Disciplina: Ciência de Dados (DCA-0131)
## Prof. Luiz Affonso Guedes

Departamento de Engenharia de Computação e Automação - DCA
UFRN - 2021

# COMPONENTES
Paula de Souza Braz,
Italo maciel e
Lays de Freitas
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **REQUISITOS PRINCIPAIS DO TRABALHO**
Trabalho 1 - EDA
Descrição:
Objetivo do Trabalho:

- Construir um Notebook Python com Análise Exploratória e Dados (EDA) sobre uma base de dados a escolha da equipe.

Objetivos Específicos: 

- Escolha da base de dados, justificando o motivo da escolha - relevância da informação associada a esses dados.

- Pré-processamento dos dados na base de dados - captura, limpeza, imputação de dados, até a produção do Dataframe adequado à análise.

- Análise exploratória dos dados utilizando técnicas estatísticas e de visualização de dados.

- Preparação do notebook Python com todas essas etapas.

 

Apresentação: 

- Produzir um vídeo de até 10 minutos contendo a explicação das diversas atividades desenvolvidas no notebook até a obtençãodos resultados da EDA.

- Publicar o vídeo no Youtube.

- Submeter o link do vídeo no Sigaa até a data de 16 de dezembro de 2021 até as 13:59 min

 

Na aula síncrona do dia 16 de dezembro de 2021 todos os vídeos submetidos no sistema serão apresentados e avaliados.



"""

# Importação do Pacote

from scipy import stats

# Commented out IPython magic to ensure Python compatibility.
from pandas import Series, DataFrame
import pandas as pd
# %matplotlib inline
# %pylab inline
import matplotlib.pyplot as plt
import seaborn as sns
plt.style.use('ggplot')
# Biblioteca para trabalhar com mapas:
!pip install folium
!pip install seaborn

"""# Coletagem do banco de dados do consumidor.gov

### Com o intuito de analisar a problematica relacionas as reclamações das empresas analisadas pelo site do governo.
"""

dataset1 = pd.read_csv('finalizadas_2021-10.csv',sep=';',encoding='utf-8')
# Visualizando as 5 primeiras linhas do Dataframe:
dataset1.head()
dataset1

"""#Começando a tratar os dados

##Qual a quantidade de reclamções por estado?
##Qual estado tem o  maior indice de reclamações solucionadas?
Iniciamos a tratar o dado referente a REGIÃO usando a função do panda Groupby, que é uma operação de agrupamento envolve alguma combinação de divisão do objeto, aplicação de uma função e combinação dos resultados. Pode-se ser usado para agrupar grandes quantidades de dados e operações de computação nesses grupos.
"""

reclamacoes = dataset1.groupby('UF')['UF'].count()
reclamacoes.array

"""**Regiões que obtiveram máximo e mínimo de reclamações**"""

print("O estado que obteve mais reclamação:", reclamacoes.index.max(), " - " , reclamacoes.max())
print("O estado que obteve menos reclamação:", reclamacoes.index.min(), " - " , reclamacoes.min())

"""**Número de Pessoas que abriram reclamações no portal do consumidor por gênero**"""

dataset3 = dataset1['Sexo'].value_counts()
dataset3

"""**Número de Pessoas respondidas por gênero**"""

dataset2 = dataset1.groupby('Sexo')['Respondida'].value_counts()
dataset2

"""**Taxa de reclamações por região associado ao gênero**"""

dataset4 = dataset1.groupby('Sexo')['Região'].value_counts()
dataset4

qntd_tipo_resposta = dataset2.array
qntd_tipo_resposta

qntd_sexo = dataset3.array
qntd_sexo

"""**Gráfico I**
<br> *Quantidade de reclamações respondidas por sexo*
"""

def total_respondidas(qntd_tipo_resposta):
    return (qntd_tipo_resposta[0]+qntd_tipo_resposta[2]+qntd_tipo_resposta[4])


txtLabels = 'Feminino', 'Masculino', 'Outros'
fractions = [(qntd_tipo_resposta[0]/total_respondidas(qntd_tipo_resposta)), (qntd_tipo_resposta[2]/total_respondidas(qntd_tipo_resposta)), (qntd_tipo_resposta[4]/total_respondidas(qntd_tipo_resposta))]
offsets =(0.05, 0.05, 0.05)
plt.pie(fractions, explode=offsets, labels=txtLabels,
autopct='%1.1f%%', shadow=True, startangle=90,
colors=sns.color_palette('muted') )
plt.show()

"""**Gráfico II**
<br> *Quantidade de reclamações não respondidas por sexo*
"""

def total_nao_respondidas(qntd_tipo_resposta):
    return (qntd_tipo_resposta[1]+qntd_tipo_resposta[3]+qntd_tipo_resposta[5])


txtLabels = 'Feminino', 'Masculino', 'Outros'
fractions = [(qntd_tipo_resposta[1]/total_nao_respondidas(qntd_tipo_resposta)), (qntd_tipo_resposta[3]/total_nao_respondidas(qntd_tipo_resposta)), (qntd_tipo_resposta[5]/total_respondidas(qntd_tipo_resposta))]
offsets =(0.05, 0.05, 0.05)
plt.pie(fractions, explode=offsets, labels=txtLabels,
autopct='%1.1f%%', shadow=True, startangle=90,
colors=sns.color_palette('muted') )
plt.show()

"""**Gráfico III**
<br> *Quantidade de reclamações abertas por sexo*
"""

def total():
    return (len(dataset1.index))


txtLabels = 'Feminino', 'Masculino', 'Outros'
fractions = [(qntd_sexo[1]/total()), (qntd_sexo[0]/total()), (qntd_sexo[2]/total())]
offsets =(0.05, 0.05, 0.05)
plt.pie(fractions, explode=offsets, labels=txtLabels,
autopct='%1.1f%%', shadow=True, startangle=90,
colors=sns.color_palette('muted') )
plt.show()

"""
**Associação das colunas:**
- Região 
- Cidade 
- UF 
- Sexo 
- Respondida 
- Faixa etária"""

Dados_associados = dataset1[['Região','Cidade','UF','Sexo','Respondida','Faixa Etária']]
Dados_associados

g_masculino = Dados_associados[Dados_associados.Sexo == 'M'][['UF','Cidade','Faixa Etária','Respondida','Região','Sexo']]
g_masculino

g_feminino = Dados_associados[Dados_associados.Sexo == 'F'][['UF','Cidade','Faixa Etária','Respondida','Região','Sexo']]
g_feminino

g_outros = Dados_associados[Dados_associados.Sexo == 'O'][['UF','Cidade','Faixa Etária','Respondida','Região','Sexo']]
g_outros

dados_hist = g_masculino['Faixa Etária'].value_counts()
print("Quantidade de reclamações masculinas por faixa etária:\n",dados_hist)
print("---------------------------------")
print("Indexamento: ",dados_hist.index)
print("---------------------------------")
print("Valores: ",dados_hist.values)

"""**Gráfico IV**
<br>*Quantidade de reclamações do gênero masculino por faixa etária*
"""

array_idade = [1,2,3,4,5,6,7]
rng = np.random.RandomState(0)
colors = rng.rand(7)
sizes = 1000 * rng.rand(7)
plt.scatter(dados_hist.values,array_idade,s = sizes, c= colors, alpha = 0.8)
plt.ylabel('Faixa Etária [em índice]')
plt.xlabel('Quantidade de Pessoas [quantidade]')
plt.title('Quantidade de reclamações masculinas por faixa etária')
plt.text(22931, 1, 'entre 31 a 40 anos')
plt.text(15351, 2, 'entre 21 a 30 anos')
plt.text(12262, 3, 'entre 41 a 50 anos')
plt.text(6618, 4, 'entre 51 a 60 anos')
plt.text(5193, 5, 'entre 61 a 70 anos')
plt.text(2363, 6, 'mais de 70 anos')
plt.text(909, 7, 'até de 20 anos')

x = [1000,10000,20000,30000,40000]
n_x = ['1k','10k','20k','30k','40k']

plt.xticks(x,n_x)
plt.show()

dados_hist = g_feminino['Faixa Etária'].value_counts()
print("Quantidade de reclamações femininas por faixa etária:\n",dados_hist)
print("---------------------------------")
print("Indexamento: ",dados_hist.index)
print("---------------------------------")
print("Valores: ",dados_hist.values)

"""**Gráfico V**
<br>*Quantidade de reclamações do gênero feminino por faixa etária*
"""

#Gráfico que mostra a quantidade de reclamações do sexo feminino por faixa etária

dados_hist.plot.barh(color = '#866f85')
plt.title('Quantidade de reclamações femininas por faixa etária')
plt.show()

"""**Gráfico VI**
<br>*Quantidade de reclamações do outros gêneros por faixa etária*
"""

dados_hist = g_outros['Faixa Etária'].value_counts()
print("Quantidade de reclamações femininas por faixa etária:\n",dados_hist)
print("---------------------------------")
print("Indexamento: ",dados_hist.index)
print("---------------------------------")
print("Valores: ",dados_hist.values)

#Gráfico que mostra a quantidade de reclamações de outros gêneros por faixa etária

dados_hist.plot.barh(color = '#c3909b')
plt.title('Quantidade de reclamações de outros gêneros por faixa etária')
plt.show()

"""**Classificação de empresas pelo tempo de resposta**"""

classificacao_empresa = dataset1[['Nome Fantasia','Tempo Resposta','Nota do Consumidor']]
classificacao_empresa

"""**Limpeza de dados nulos**
<br> Considerando somente os usuários que avaliaram os atendimentos e obtiveram algum tempo de resposta.
"""

limpeza_dados = classificacao_empresa.dropna()
limpeza_dados

oficial = limpeza_dados.groupby('Nome Fantasia')['Nota do Consumidor'].value_counts()
oficial

"""**Observação:** Tem que levar em consideração das avaliações nulas (linhas retiradas) e ao total de reclamações correspondente a cada empresa. Avaliar a discrepância causada."""

quantitativo = Series(oficial)
quantitativo.head(14)

"""**Observação:** A média do numpy estava calculando de maneira incorreta, estava somando a segunda coluna e dividindo pela quantidade de tipo de classificação do consumidor."""

print('------------------------- Biblioteca Numpy -----------------------------')
media = quantitativo.head(5).mean()
print('123 Milhas ---- Média:', media)
desvio_padrao = quantitativo.head(5).std()
print('123 Milhas ---- Desvio Padrão:', desvio_padrao)
mediana = quantitativo.head(5).median()
print('123 Milhas ---- Mediana:', mediana)
variancia = quantitativo.head(5).var()
print('123 Milhas ---- Variância:', variancia)

print('------------------------- cálculo correto ------------------------------')
media_real_1 = (168*1+84*5+43*3+36*4+29*2)/(360)
print('123 Milhas ---- Média de nota do consumidor:', media_real_1)
mediana_real_1 = (360+1)/2 # (n+1)/2
print('123 Milhas ---- Mediana de nota do consumidor:', mediana_real_1)
media_real_2 = (101*1+28*5+12*3+10*4+6*2)/(157)
print('99App ---- Média de nota do consumidor:', media_real_2)
mediana_real_2 = (157+1)/2 # (n+1)/2
print('99App ---- Mediana de nota do consumidor:', mediana_real_2)
media_real_3 = (15*1+3*5+2*3+3*4)/(23)
print('99Food ---- Média de nota do consumidor:', media_real_3)
mediana_real_3 = (23+1)/2 # (n+1)/2
print('99Food ---- Mediana de nota do consumidor:', mediana_real_3)

print("---------------------------------------------------------------------------------------------")
Rank = {'1º Lugar: ' : '123 Milhas', '2º Lugar: ' : '99App', '3º Lugar: ' : '99Food', '...' : '...', 'nº lugar' : '...'}
print("Rank de empresas", Rank)

"""Analise

**Gráfico VII**
"""

df2 = dataset1[dataset1['Como Comprou Contratou']=='Internet']
df2.groupby('Faixa Etária')['Como Comprou Contratou'].value_counts().plot.barh()
plt.show()

"""**Gráfico VIII**"""

#Estes consumidores procuram a empresa antes de registrar uma reclamação?
df2 = dataset1[dataset1['Faixa Etária']=='entre 21 a 30 anos']
df2['Procurou Empresa'].value_counts().plot.barh()
plt.show()

"""**Gráfico IX**"""

#Estes consumidores procuram a empresa antes de registrar uma reclamação?
df2 = dataset1[dataset1['Faixa Etária']=='entre 31 a 40 anos']
df2['Procurou Empresa'].value_counts().plot.barh()
plt.show()

#Qual o grupo de problema mais comum ?
dataset1['Grupo Problema'].value_counts()
dataset1[dataset1['Grupo Problema'] == 'Cobrança / Contestação']['Problema'].value_counts()

dados_segmento = dataset1['Segmento de Mercado'].value_counts().head()
dados_segmento.array

"""**Gráfico X**
<br> *Quantidade de reclamações por segmento de mercado*
"""

array_indice = [1,2,3,4,5]
rng = np.random.RandomState(10)
colors = rng.rand(5)
plt.scatter(dados_segmento,array_indice,s = [10000,5000,2500,1000,500], c=colors , alpha = 0.8)
plt.ylabel('Segmento de mercado [em índice]')
plt.xlabel('Quantidade de Reclamações [quantidade]')
plt.title('Quantidade de reclamações por segmento de mercado')
plt.text(36483, 1, 'Bancos')
plt.text(25027, 2, 'Operadoras de Telecomunicação')
plt.text(11407, 3, 'Transporte Aéreo')
plt.text(7927, 4, 'Comércio Eletrônico')
plt.text(5156, 5, 'Seguros')

x = [0,10000,20000,30000,40000,50000]
n_x = ['0','10k','20k','30k','40k','50k']

plt.xticks(x,n_x)
plt.show()

"""**Gráfico XI**
<br> *Quantidade de Reclamações resolvidas/não resolvidas por região*
"""

sns.set_theme(style="darkgrid")
ax = sns.countplot( y="Região", hue = "Avaliação Reclamação", data=dataset1)
plt.title("Quantidade de Reclamações resolvidas/não resolvidas por região")
plt.show()